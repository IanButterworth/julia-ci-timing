<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Julia CI Timing</title>
    <link rel="icon" type="image/svg+xml" href="https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia-dots.svg">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* GitHub-style colors with automatic light/dark mode */
        :root {
            --color-canvas-default: #ffffff;
            --color-canvas-subtle: #f6f8fa;
            --color-canvas-inset: #eff2f5;
            --color-border-default: #d0d7de;
            --color-border-muted: #d8dee4;
            --color-fg-default: #1f2328;
            --color-fg-muted: #656d76;
            --color-fg-subtle: #6e7781;
            --color-accent-fg: #0969da;
            --color-accent-emphasis: #0969da;
            --color-success-fg: #1a7f37;
            --color-danger-fg: #d1242f;
            --color-attention-fg: #9a6700;
            --color-btn-bg: #f6f8fa;
            --color-btn-border: rgba(31,35,40,0.15);
            --color-btn-hover-bg: #f3f4f6;
            --color-btn-active-bg: hsla(220,14%,93%,1);
            --color-btn-primary-bg: #1f883d;
            --color-btn-primary-border: rgba(31,35,40,0.15);
            --color-btn-primary-hover-bg: #1a7f37;
            --color-neutral-muted: rgba(175,184,193,0.2);
            --color-overlay-shadow: 0 1px 3px rgba(31,35,40,0.12), 0 8px 24px rgba(66,74,83,0.12);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --color-canvas-default: #0d1117;
                --color-canvas-subtle: #161b22;
                --color-canvas-inset: #010409;
                --color-border-default: #30363d;
                --color-border-muted: #21262d;
                --color-fg-default: #e6edf3;
                --color-fg-muted: #8b949e;
                --color-fg-subtle: #6e7681;
                --color-accent-fg: #58a6ff;
                --color-accent-emphasis: #1f6feb;
                --color-success-fg: #3fb950;
                --color-danger-fg: #f85149;
                --color-attention-fg: #d29922;
                --color-btn-bg: #21262d;
                --color-btn-border: rgba(240,246,252,0.1);
                --color-btn-hover-bg: #30363d;
                --color-btn-active-bg: hsla(212,12%,18%,1);
                --color-btn-primary-bg: #238636;
                --color-btn-primary-border: rgba(240,246,252,0.1);
                --color-btn-primary-hover-bg: #2ea043;
                --color-neutral-muted: rgba(110,118,129,0.4);
                --color-overlay-shadow: 0 0 0 1px #30363d, 0 16px 32px rgba(1,4,9,0.85);
            }
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; overflow: hidden; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--color-canvas-default);
            color: var(--color-fg-default);
            font-size: 14px;
            display: flex;
            flex-direction: column;
        }

        /* Top toolbar */
        .toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--color-canvas-subtle);
            border-bottom: 1px solid var(--color-border-default);
            flex-shrink: 0;
        }
        .toolbar h1 {
            font-size: 16px;
            font-weight: 500;
            color: var(--color-fg-default);
            margin-right: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .julia-logo {
            height: 18px;
            width: auto;
        }
        .toolbar .updated {
            color: var(--color-fg-muted);
            font-size: 12px;
            margin-left: auto;
        }
        .btn {
            padding: 5px 12px;
            font-size: 12px;
            font-weight: 500;
            background: var(--color-btn-bg);
            border: 1px solid var(--color-btn-border);
            border-radius: 6px;
            color: var(--color-fg-default);
            cursor: pointer;
            line-height: 20px;
        }
        .btn:hover { background: var(--color-btn-hover-bg); }
        .btn-link { text-decoration: none; }
        .time-select {
            padding: 4px 8px;
            font-size: 12px;
            background: var(--color-btn-bg);
            border: 1px solid var(--color-btn-border);
            border-radius: 6px;
            color: var(--color-fg-default);
            cursor: pointer;
        }
        .btn.primary {
            background: var(--color-btn-primary-bg);
            border-color: var(--color-btn-primary-border);
            color: #fff;
        }
        .btn.primary:hover { background: var(--color-btn-primary-hover-bg); }

        /* Main layout */
        .main {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        /* Sidebar with matrix */
        .sidebar {
            width: 320px;
            background: var(--color-canvas-subtle);
            border-right: 1px solid var(--color-border-default);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        /* Job Matrix */
        .job-matrix {
            padding: 8px;
            flex-shrink: 0;
        }
        .matrix-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }
        .matrix-table th, .matrix-table td {
            padding: 4px 6px;
            text-align: center;
            border: 1px solid var(--color-border-muted);
        }
        .matrix-table th {
            background: var(--color-canvas-inset);
            font-weight: 600;
            color: var(--color-fg-default);
        }
        .matrix-table th.clickable {
            cursor: pointer;
        }
        .matrix-table th.clickable:hover {
            background: var(--color-neutral-muted);
        }
        .matrix-table th.row-header {
            text-align: left;
            white-space: nowrap;
        }
        .matrix-cell {
            cursor: pointer;
            min-width: 50px;
            position: relative;
        }
        .matrix-cell:hover {
            background: var(--color-neutral-muted);
        }
        .matrix-cell .job-count {
            font-size: 10px;
            color: var(--color-fg-muted);
        }
        .matrix-cell.has-selection {
            background: var(--color-btn-primary-bg);
            color: #fff;
        }
        .matrix-cell.has-selection .job-count {
            color: rgba(255,255,255,0.8);
        }
        .matrix-cell.partial-selection {
            background: rgba(31, 136, 61, 0.25);
        }
        .matrix-corner {
            cursor: default;
        }

        /* Job list below matrix */
        .job-list-section {
            border-top: 1px solid var(--color-border-default);
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }
        .job-list-header {
            padding: 4px 12px;
            font-size: 11px;
            font-weight: 600;
            color: var(--color-fg-muted);
            flex-shrink: 0;
        }
        .job-list {
            padding: 0;
            flex: 1;
            overflow-y: auto;
        }
        .job-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 2px 12px;
            font-size: 10px;
            cursor: pointer;
            opacity: 0.4;
        }
        .job-item:hover { background: var(--color-neutral-muted); }
        .job-item.selected { opacity: 1; }
        .job-item .job-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--color-fg-default);
        }
        .job-item .job-median {
            color: var(--color-fg-muted);
            font-size: 9px;
            font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace;
        }
        .color-dot { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; }
        .bk-emoji { height: 1em; width: 1em; vertical-align: -0.1em; display: inline; }
        .failure-rate { font-size: 9px; color: var(--color-danger-fg); margin-left: auto; padding-left: 6px; white-space: nowrap; }
        .failure-indicator { color: var(--color-danger-fg); font-size: 9px; margin-left: 2px; }
        .matrix-cell .failure-indicator { position: absolute; top: 1px; right: 2px; font-size: 8px; }

        /* Chart area */
        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            background: var(--color-canvas-default);
        }
        .chart-container {
            flex: 1;
            padding: 12px;
            min-height: 0;
            position: relative;
        }
        .chart-wrapper {
            position: absolute;
            top: 12px;
            left: 12px;
            right: 12px;
            bottom: 12px;
        }

        /* Stats bar */
        .stats-wrapper {
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            min-height: 50px;
            max-height: 70vh;
        }
        .resize-handle {
            height: 6px;
            background: var(--color-border-default);
            cursor: ns-resize;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .resize-handle::after {
            content: '';
            width: 40px;
            height: 3px;
            background: var(--color-fg-muted);
            border-radius: 2px;
            opacity: 0.5;
        }
        .resize-handle:hover { background: var(--color-neutral-muted); }
        .resize-handle:hover::after { opacity: 1; }
        .stats-bar {
            display: flex;
            gap: 1px;
            background: var(--color-border-default);
            flex: 1;
            font-size: 12px;
            overflow-y: auto;
        }
        .stats-bar table {
            width: 100%;
            border-collapse: collapse;
            background: var(--color-canvas-subtle);
        }
        .stats-bar th, .stats-bar td {
            padding: 6px 12px;
            text-align: left;
            border-bottom: 1px solid var(--color-border-muted);
        }
        .stats-bar th {
            background: var(--color-canvas-inset);
            color: var(--color-fg-muted);
            font-weight: 600;
            font-size: 11px;
            position: sticky;
            top: 0;
        }
        .stats-bar th.sortable {
            cursor: pointer;
            user-select: none;
        }
        .stats-bar th.sortable:hover {
            background: var(--color-neutral-muted);
            color: var(--color-fg-default);
        }
        .stats-bar th .sort-indicator {
            margin-left: 4px;
            opacity: 0.3;
        }
        .stats-bar th.sorted .sort-indicator {
            opacity: 1;
        }
        .stats-bar th.sorted {
            color: var(--color-fg-default);
        }
        .stats-bar td {
            font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace;
            font-size: 11px;
        }
        .stats-bar tr:hover { background: var(--color-neutral-muted); }

        .loading { padding: 20px; text-align: center; color: var(--color-fg-muted); }
        .loading-overlay { 
            position: absolute; 
            top: 0; left: 0; right: 0; bottom: 0; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            background: var(--color-canvas-default); 
            z-index: 10; 
        }
        .error { color: var(--color-danger-fg); }

        /* Popup */
        .popup-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        .popup-overlay.visible { display: flex; align-items: center; justify-content: center; }
        .popup {
            background: var(--color-canvas-default);
            border: 1px solid var(--color-border-default);
            border-radius: 12px;
            padding: 16px;
            min-width: 300px;
            max-width: 420px;
            box-shadow: var(--color-overlay-shadow);
            position: relative;
        }
        .popup-close {
            position: absolute;
            top: 12px;
            right: 12px;
            background: none;
            border: none;
            font-size: 18px;
            color: var(--color-fg-muted);
            cursor: pointer;
            padding: 4px;
            line-height: 1;
        }
        .popup-close:hover { color: var(--color-fg-default); }
        .popup h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--color-fg-default);
        }
        .popup-info { font-size: 13px; }
        .popup-info div { margin: 6px 0; }
        .popup-info .label { color: var(--color-fg-muted); }
        .popup-info a {
            color: var(--color-accent-fg);
            text-decoration: none;
        }
        .popup-info a:hover { text-decoration: underline; }
        .popup-info code {
            font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace;
            background: var(--color-neutral-muted);
            padding: 2px 6px;
            border-radius: 6px;
            font-size: 12px;
        }
        .popup-info a code:hover { background: var(--color-btn-hover-bg); }

        /* Mobile responsive */
        @media (max-width: 768px) {
            html, body { overflow: auto; }
            body { height: auto; min-height: 100vh; }

            .toolbar {
                flex-wrap: wrap;
                gap: 4px;
                padding: 6px 10px;
            }
            .toolbar h1 {
                width: auto;
                margin-right: auto;
                margin-bottom: 0;
                font-size: 13px;
            }
            .toolbar .updated {
                width: auto;
                margin-left: 0;
                font-size: 10px;
                order: 10;
            }
            .btn, .time-select {
                padding: 4px 8px;
                font-size: 10px;
            }
            .btn-link {
                display: none;
            }

            .main {
                flex-direction: column;
                min-height: auto;
            }

            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid var(--color-border-default);
                max-height: none;
            }

            .job-matrix {
                padding: 8px;
                overflow-x: auto;
            }
            .matrix-table {
                font-size: 10px;
            }
            .matrix-table th, .matrix-table td {
                padding: 3px 4px;
            }
            .matrix-cell {
                min-width: 40px;
            }

            .job-list-section {
                max-height: 150px;
            }

            .content {
                min-height: 400px;
            }

            .chart-container {
                min-height: 300px;
                padding: 8px;
            }
            .chart-wrapper {
                position: relative;
                top: 0; left: 0; right: 0; bottom: 0;
                height: 280px;
            }

            .stats-wrapper {
                max-height: 50vh;
            }
            .stats-bar th, .stats-bar td {
                padding: 4px 8px;
                font-size: 10px;
            }

            .popup {
                margin: 16px;
                min-width: auto;
                max-width: calc(100vw - 32px);
            }
        }
    </style>
</head>
<body>
    <div class="toolbar" role="toolbar" aria-label="Dashboard controls">
        <h1><img src="https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia-dots.svg" alt="Julia" class="julia-logo"><a href="https://github.com/JuliaLang" target="_blank" style="color: var(--color-fg-muted); text-decoration: none; font-weight: 400;">JuliaLang</a> / <a href="https://github.com/JuliaLang/julia" target="_blank" style="color: inherit; text-decoration: none; font-weight: 600;">julia</a> <span style="color: var(--color-fg-muted); font-weight: 300;">|</span> CI Timing</h1>
        <button class="btn" id="btn-all" onclick="selectAllJobs()" aria-label="Select all jobs">All</button>
        <button class="btn" id="btn-none" onclick="deselectAllJobs()" aria-label="Deselect all jobs">None</button>
        <select class="time-select" id="time-range" onchange="setTimeRange(this.value)" aria-label="Time range">
            <option value="custom" disabled>Custom</option>
            <option value="7">Last 7 days</option>
            <option value="14">Last 14 days</option>
            <option value="30" selected>Last 30 days</option>
            <option value="60">Last 60 days</option>
            <option value="90">Last 90 days</option>
            <option value="0">All time</option>
        </select>
        <button class="btn" id="btn-reset-zoom" onclick="resetZoom()" aria-label="Reset zoom" style="display: none;">Reset</button>
        <select class="time-select" id="line-type" onchange="setLineType(this.value)" aria-label="Line type">
            <option value="raw">Raw data</option>
            <option value="7" selected>7-day avg</option>
            <option value="30">30-day avg</option>
            <option value="90">90-day avg</option>
        </select>
        <select class="time-select" id="state-filter" onchange="setStateFilter(this.value)" aria-label="State filter">
            <option value="all" selected>All states</option>
            <option value="passed">Passed only</option>
            <option value="failed">Failed only</option>
        </select>
        <span class="updated" id="last-updated" aria-live="polite"></span>
        <a href="https://github.com/JuliaCI/julia-ci-timing/commit/__BUILD_COMMIT__" target="_blank" class="updated" id="build-commit" title="Site build commit" style="text-decoration: none;">__BUILD_COMMIT_SHORT__</a>
        <a href="https://github.com/JuliaCI/julia-ci-timing" target="_blank" class="btn btn-link" aria-label="View source on GitHub">GitHub</a>
    </div>

    <div class="popup-overlay" id="popup-overlay" onclick="closePopup(event)" role="dialog" aria-modal="true" aria-labelledby="popup-title">
        <div class="popup" onclick="event.stopPropagation()">
            <button class="popup-close" onclick="document.getElementById('popup-overlay').classList.remove('visible')" aria-label="Close dialog">√ó</button>
            <h3 id="popup-title">Job Details</h3>
            <div class="popup-info">
                <div><span class="label">Job:</span> <span id="popup-job"></span></div>
                <div><span class="label">Status:</span> <span id="popup-state"></span></div>
                <div><span class="label">Duration:</span> <span id="popup-duration"></span></div>
                <div><span class="label">Agent:</span> <span id="popup-agent"></span></div>
                <div><span class="label">Date:</span> <span id="popup-date"></span></div>
                <div><span class="label">Commit:</span> <a id="popup-github-link" href="#" target="_blank"><code id="popup-commit"></code></a></div>
                <div><span class="label">Title:</span> <span id="popup-message"></span></div>
                <div><span class="label">Author:</span> <span id="popup-author"></span></div>
                <div><span class="label">Build:</span> <a id="popup-buildkite-link" href="#" target="_blank"><span id="popup-build"></span></a></div>
            </div>
        </div>
    </div>

    <main class="main">
        <aside class="sidebar" aria-label="Job selection">
            <div class="job-matrix" id="job-matrix" role="grid" aria-label="Platform and test type matrix"><div class="loading">Loading...</div></div>
            <div class="job-list-section">
                <div class="job-list-header">Jobs (<span id="job-count">0/0</span>)</div>
                <div class="job-list" id="job-list" role="listbox" aria-label="Available jobs"><div class="loading">Loading jobs...</div></div>
            </div>
        </aside>
        <div class="content">
            <div class="chart-container">
                <div class="chart-wrapper">
                    <div class="loading-overlay" id="chart-loading"><span class="loading">Loading chart data...</span></div>
                    <canvas id="timing-chart" role="img" aria-label="CI timing chart"></canvas>
                </div>
            </div>
            <div class="stats-wrapper" id="stats-wrapper" style="height: 150px;">
                <div class="resize-handle" id="resize-handle" role="separator" aria-orientation="horizontal" aria-label="Resize stats panel"></div>
                <div class="stats-bar">
                    <table role="table" aria-label="Job statistics">
                        <thead>
                            <tr>
                                <th scope="col" class="sortable" data-sort="job" onclick="handleStatsTableSort('job')">Job <span class="sort-indicator">‚ñ≤</span></th>
                                <th scope="col" class="sortable" data-sort="passRate" title="Pass rate in last 14 days" onclick="handleStatsTableSort('passRate')">Pass Rate <span class="sort-indicator">‚ñ≤</span></th>
                                <th scope="col" class="sortable" data-sort="median" onclick="handleStatsTableSort('median')">Median <span class="sort-indicator">‚ñ≤</span></th>
                                <th scope="col" class="sortable" data-sort="mean" onclick="handleStatsTableSort('mean')">Mean <span class="sort-indicator">‚ñ≤</span></th>
                                <th scope="col" class="sortable" data-sort="min" onclick="handleStatsTableSort('min')">Min <span class="sort-indicator">‚ñ≤</span></th>
                                <th scope="col" class="sortable" data-sort="max" onclick="handleStatsTableSort('max')">Max <span class="sort-indicator">‚ñ≤</span></th>
                                <th scope="col" class="sortable" data-sort="std" onclick="handleStatsTableSort('std')">œÉ <span class="sort-indicator">‚ñ≤</span></th>
                                <th scope="col" class="sortable" data-sort="trend" title="Trend over selected time range" onclick="handleStatsTableSort('trend')">Trend <span class="sort-indicator">‚ñ≤</span></th>
                                <th scope="col" class="sortable" data-sort="n" onclick="handleStatsTableSort('n')">n <span class="sort-indicator">‚ñ≤</span></th>
                            </tr>
                        </thead>
                        <tbody id="stats-tbody">
                            <tr><td colspan="9" class="loading">Loading...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </main>

    <script>
        'use strict';

        // === Constants ===
        const FAILED_STATES = ['failed', 'timed_out', 'canceled'];
        const VALID_TIME_RANGES = [0, 7, 14, 30, 60, 90];

        // Stats table sorting state
        let statsTableSortColumn = 'median';
        let statsTableSortAsc = false;  // false = descending (largest first)
        const VALID_LINE_TYPES = ['raw', '7', '30', '90'];
        const VALID_STATE_FILTERS = ['all', 'passed', 'failed'];
        const DEFAULT_TIME_RANGE = 30;
        const DEFAULT_LINE_TYPE = '7';
        const DEFAULT_STATE_FILTER = 'all';
        const STORAGE_KEY = 'julia-ci-timing-config';
        const DATA_REFRESH_INTERVAL = 5 * 60 * 1000;  // 5 minutes
        const AGO_UPDATE_INTERVAL = 60 * 1000;        // 1 minute

        // === State ===
        let chart = null;
        let data = null;
        let selectedJobs = new Set();
        let timeRangeDays = DEFAULT_TIME_RANGE;
        let lineType = DEFAULT_LINE_TYPE;
        let stateFilter = DEFAULT_STATE_FILTER;
        let jobColors = {};
        let chartMetadata = {};
        // Custom zoom state (null = use timeRangeDays preset)
        let customXMin = null;  // timestamp or null
        let customXMax = null;  // timestamp or null
        let customYMin = null;  // seconds or null
        let customYMax = null;  // seconds or null

        // === Helper Functions ===
        const isFailedState = (state) => FAILED_STATES.includes(state);
        const getRunState = (run) => run.state || 'passed';

        function refreshAllUI() {
            updateMatrixHighlights();
            updateJobCount();
            updateChart();
            updateStatsTable();
            updateToolbarButtons();
        }

        function toggleJobsSelection(jobs) {
            if (jobs.length === 0) return;
            const allSelected = jobs.every(j => selectedJobs.has(j.name));
            for (const { name } of jobs) {
                if (allSelected) {
                    selectedJobs.delete(name);
                } else {
                    selectedJobs.add(name);
                }
            }
        }

        // Buildkite emoji mapping - use their actual images
        const BUILDKITE_EMOJI_BASE = 'https://buildkiteassets.com/emojis/img-buildkite-64';
        const emojiImageMap = {
            ':macos:': `${BUILDKITE_EMOJI_BASE}/mac.png`,
            ':apple:': `${BUILDKITE_EMOJI_BASE}/mac.png`,
            ':mac:': `${BUILDKITE_EMOJI_BASE}/mac.png`,
            ':linux:': `${BUILDKITE_EMOJI_BASE}/linux.png`,
            ':windows:': `${BUILDKITE_EMOJI_BASE}/windows.png`,
            ':freebsd:': `${BUILDKITE_EMOJI_BASE}/freebsd.png`,
        };
        const emojiMap = {
            ':rocket:': 'üöÄ',
            ':gear:': '‚öôÔ∏è',
            ':package:': 'üì¶',
            ':test_tube:': 'üß™',
            ':memo:': 'üìù',
            ':lock:': 'üîí',
            ':key:': 'üîë',
            ':warning:': '‚ö†Ô∏è',
            ':x:': '‚ùå',
            ':white_check_mark:': '‚úÖ',
            ':hourglass:': '‚è≥',
            ':zap:': '‚ö°',
        };

        // Unicode fallbacks for canvas/tooltip contexts that can't render HTML
        const emojiTextMap = {
            ':macos:': 'üçé',
            ':apple:': 'üçé',
            ':mac:': 'üçé',
            ':linux:': 'üêß',
            ':windows:': 'ü™ü',
            ':freebsd:': 'üòà',
        };

        function convertEmoji(text) {
            let result = text;
            // First, replace with Buildkite images
            for (const [code, url] of Object.entries(emojiImageMap)) {
                result = result.replaceAll(code, `<img src="${url}" alt="${code}" class="bk-emoji">`);
            }
            // Then replace remaining emoji codes with unicode
            for (const [code, emoji] of Object.entries(emojiMap)) {
                result = result.replaceAll(code, emoji);
            }
            return result;
        }

        // Plain text version for canvas tooltips
        function convertEmojiText(text) {
            let result = text;
            for (const [code, emoji] of Object.entries(emojiTextMap)) {
                result = result.replaceAll(code, emoji);
            }
            for (const [code, emoji] of Object.entries(emojiMap)) {
                result = result.replaceAll(code, emoji);
            }
            return result;
        }

        // Generate distinct colors for jobs using golden ratio for better distribution
        function generateColors(count) {
            const colors = [];
            const goldenRatio = 0.618033988749895;
            let hue = 0;
            for (let i = 0; i < count; i++) {
                // Use golden ratio to spread hues evenly
                hue = (hue + goldenRatio) % 1;
                // Vary saturation and lightness slightly for more distinction
                const saturation = 65 + (i % 3) * 10;  // 65%, 75%, 85%
                const lightness = 45 + (i % 5) * 5;    // 45%, 50%, 55%, 60%, 65%
                colors.push(`hsl(${Math.floor(hue * 360)}, ${saturation}%, ${lightness}%)`);
            }
            return colors;
        }

        function formatDuration(seconds) {
            if (seconds < 60) return `${seconds.toFixed(1)}s`;
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(0);
            if (mins < 60) return `${mins}m ${secs}s`;
            const hours = Math.floor(mins / 60);
            const remainMins = mins % 60;
            return `${hours}h ${remainMins}m`;
        }

        // Compute trend using linear regression with statistical significance
        // Returns: { slope, slopePerDay, pValue, significant, direction }
        function computeTrend(runs) {
            if (runs.length < 3) return null;

            // Convert to numeric: x = timestamp (days), y = duration (seconds)
            const points = runs.map(r => ({
                x: new Date(r.date).getTime() / (1000 * 60 * 60 * 24), // days since epoch
                y: r.duration
            }));

            const n = points.length;
            const sumX = points.reduce((s, p) => s + p.x, 0);
            const sumY = points.reduce((s, p) => s + p.y, 0);
            const sumXY = points.reduce((s, p) => s + p.x * p.y, 0);
            const sumX2 = points.reduce((s, p) => s + p.x * p.x, 0);
            const sumY2 = points.reduce((s, p) => s + p.y * p.y, 0);

            const meanX = sumX / n;
            const meanY = sumY / n;

            // Slope and intercept
            const denom = sumX2 - n * meanX * meanX;
            if (Math.abs(denom) < 1e-10) return null;

            const slope = (sumXY - n * meanX * meanY) / denom;

            // Standard error of slope for t-test
            const yPred = points.map(p => meanY + slope * (p.x - meanX));
            const ssRes = points.reduce((s, p, i) => s + (p.y - yPred[i]) ** 2, 0);
            const ssTot = points.reduce((s, p) => s + (p.y - meanY) ** 2, 0);

            const rSquared = ssTot > 0 ? 1 - ssRes / ssTot : 0;

            // Standard error of slope
            const mse = ssRes / (n - 2);
            const seSlope = Math.sqrt(mse / (sumX2 - n * meanX * meanX));

            // t-statistic
            const tStat = seSlope > 0 ? Math.abs(slope) / seSlope : 0;

            // Approximate p-value using t-distribution (two-tailed)
            // Using approximation for degrees of freedom = n - 2
            const df = n - 2;
            const pValue = tDistributionPValue(tStat, df);

            // Calculate percentage change over the time range
            const minX = Math.min(...points.map(p => p.x));
            const maxX = Math.max(...points.map(p => p.x));
            const intercept = meanY - slope * meanX;
            const startValue = intercept + slope * minX;
            const endValue = intercept + slope * maxX;
            const percentChange = startValue > 0 ? ((endValue - startValue) / startValue) * 100 : 0;

            return {
                slope,           // seconds per day
                slopePerDay: slope,
                pValue,
                rSquared,
                significant: pValue < 0.05,
                direction: slope > 0 ? 'up' : slope < 0 ? 'down' : 'flat',
                percentChange,
                n
            };
        }

        // Approximate two-tailed p-value for t-distribution
        function tDistributionPValue(t, df) {
            // Using approximation from Abramowitz and Stegun
            const x = df / (df + t * t);
            // Regularized incomplete beta function approximation
            const a = df / 2;
            const b = 0.5;

            // Simple approximation for p-value
            if (df >= 30) {
                // For large df, t approaches normal
                const z = t;
                return 2 * (1 - normalCDF(Math.abs(z)));
            }

            // For smaller df, use a rougher approximation
            // This is a simplified approximation
            const p = Math.exp(-0.5 * t * t) * Math.sqrt(df / (df + t * t));
            return Math.min(1, Math.max(0, 2 * p * (1 + 0.5 / df)));
        }

        function normalCDF(x) {
            const a1 =  0.254829592;
            const a2 = -0.284496736;
            const a3 =  1.421413741;
            const a4 = -1.453152027;
            const a5 =  1.061405429;
            const p  =  0.3275911;

            const sign = x < 0 ? -1 : 1;
            x = Math.abs(x) / Math.sqrt(2);

            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);

            return 0.5 * (1.0 + sign * y);
        }

        function formatTrend(trend) {
            if (!trend || trend.n < 3) {
                return '<span style="color: var(--color-fg-muted)" title="Not enough data points">‚Äî</span>';
            }

            const { slope, pValue, significant, rSquared, percentChange } = trend;
            const absSlope = Math.abs(slope);
            const absPct = Math.abs(percentChange);

            // Convert slope to human-readable format (per day)
            let slopeText;
            if (absSlope < 1) {
                slopeText = `${(absSlope * 60).toFixed(1)}s/day`;
            } else if (absSlope < 60) {
                slopeText = `${absSlope.toFixed(1)}s/day`;
            } else {
                slopeText = `${(absSlope / 60).toFixed(1)}m/day`;
            }

            // Format percentage change
            const pctSign = percentChange > 0 ? '+' : '';
            const pctText = `${pctSign}${percentChange.toFixed(1)}%`;

            // Direction arrow and color
            let arrow, color;
            if (!significant) {
                arrow = '‚Üí';
                color = 'var(--color-fg-muted)';
            } else if (slope > 0) {
                arrow = '‚Üó';
                color = 'var(--color-danger-fg)';  // Getting slower is bad
            } else {
                arrow = '‚Üò';
                color = 'var(--color-success-fg)'; // Getting faster is good
            }

            // Confidence indicator
            const confidence = significant ? (pValue < 0.01 ? '‚òÖ‚òÖ' : '‚òÖ') : '';
            const pText = pValue < 0.001 ? '<0.001' : pValue.toFixed(3);
            const title = `${slope > 0 ? '+' : ''}${slopeText} (${pctText} over period)\np-value: ${pText}\nR¬≤: ${(rSquared * 100).toFixed(1)}%\n${significant ? 'Statistically significant' : 'Not significant'}`;

            const displayText = significant ? `${pctText}` : 'flat';
            return `<span style="color: ${color}" title="${title}">${arrow} ${displayText} ${confidence}</span>`;
        }

        function filterRunsByState(runs, cutoff) {
            return runs.filter(r => {
                const date = new Date(r.date);
                if (cutoff && date < cutoff) return false;
                const runState = getRunState(r);
                if (stateFilter === 'passed' && runState !== 'passed') return false;
                if (stateFilter === 'failed' && !isFailedState(runState)) return false;
                return true;
            });
        }

        // Calculate pass rate for a job over the last N days
        const PASS_RATE_DAYS = 14;
        const PASS_RATE_THRESHOLD = 0.9;  // Below 90% shows warning
        const PASS_RATE_MIN_RUNS = 3;     // Need at least 3 runs to show warning

        function getJobPassRate(jobData) {
            const cutoff = new Date();
            cutoff.setDate(cutoff.getDate() - PASS_RATE_DAYS);

            let total = 0, passed = 0, failed = 0, timedOut = 0, canceled = 0;
            for (const run of jobData.recent) {
                const date = new Date(run.date);
                if (date < cutoff) continue;
                total++;
                const state = run.state || 'passed';
                if (state === 'passed') passed++;
                else if (state === 'failed') failed++;
                else if (state === 'timed_out') timedOut++;
                else if (state === 'canceled') canceled++;
            }
            return { total, passed, failed, timedOut, canceled, rate: total > 0 ? passed / total : 1 };
        }

        // Cache pass rates for all jobs
        let jobPassRates = {};
        function calculateAllPassRates() {
            jobPassRates = {};
            for (const [name, job] of Object.entries(data.jobs)) {
                jobPassRates[name] = getJobPassRate(job);
            }
        }

        // URL parameter handling for shareable links
        const urlCodes = {
            // Platform codes
            'linux': 'l', 'macos': 'm', 'windows': 'w', 'freebsd': 'f',
            // Type codes
            'build': 'b', 'test': 't', 'upload': 'u', 'coverage': 'c',
            // Special group codes
            'juliasyntax': 'js', 'docs': 'd', 'special': 'sp', 'pipeline': 'p', 'upload-results': 'ur', 'other': 'o'
        };
        const urlCodesReverse = Object.fromEntries(Object.entries(urlCodes).map(([k, v]) => [v, k]));

        // Job index mapping for URL encoding (built after data loads)
        let jobIndexMap = {};  // name -> index
        let jobNameList = [];  // index -> name

        function buildJobIndex() {
            jobNameList = Object.keys(data.jobs).sort();
            jobIndexMap = {};
            jobNameList.forEach((name, i) => jobIndexMap[name] = i);
        }

        function encodeSelection() {
            const parts = [];
            const coveredJobs = new Set();

            // Encode matrix cells that are fully selected
            for (const platform of platformOrder) {
                for (const type of typeOrder) {
                    const jobs = jobMatrix[platform]?.[type] || [];
                    if (jobs.length > 0 && jobs.every(j => selectedJobs.has(j.name))) {
                        parts.push(urlCodes[platform] + urlCodes[type]);
                        jobs.forEach(j => coveredJobs.add(j.name));
                    }
                }
            }
            // Encode special groups that are fully selected
            for (const group of specialGroups) {
                const jobs = specialJobGroups[group] || [];
                if (jobs.length > 0 && jobs.every(j => selectedJobs.has(j.name))) {
                    parts.push(urlCodes[group]);
                    jobs.forEach(j => coveredJobs.add(j.name));
                }
            }

            // Encode remaining individual jobs by index
            const individualIndices = [];
            for (const name of selectedJobs) {
                if (!coveredJobs.has(name) && jobIndexMap[name] !== undefined) {
                    individualIndices.push(jobIndexMap[name]);
                }
            }
            if (individualIndices.length > 0) {
                parts.push('i' + individualIndices.sort((a, b) => a - b).join('_'));
            }

            return parts.join('.');
        }

        function decodeSelection(param) {
            if (!param) return null;
            const selections = { matrix: [], special: [], indices: [] };
            for (const part of param.split('.')) {
                if (part.startsWith('i')) {
                    // Individual job indices: i0_5_12
                    const indices = part.slice(1).split('_').map(Number).filter(n => !isNaN(n));
                    selections.indices.push(...indices);
                } else if (part.length === 2 && urlCodesReverse[part[0]] && urlCodesReverse[part[1]]) {
                    // Matrix cell: e.g., "lb" = linux-build
                    const platform = urlCodesReverse[part[0]];
                    const type = urlCodesReverse[part[1]];
                    if (platform && type) selections.matrix.push({ platform, type });
                } else {
                    // Special group
                    const group = urlCodesReverse[part];
                    if (group) selections.special.push(group);
                }
            }
            return selections;
        }

        function updateURL() {
            const encoded = encodeSelection();
            const url = new URL(window.location);
            if (encoded) {
                url.searchParams.set('s', encoded);
            } else {
                url.searchParams.delete('s');
            }
            // Add time range if not default (and not custom zoom)
            if (customXMin === null && timeRangeDays !== DEFAULT_TIME_RANGE) {
                url.searchParams.set('t', timeRangeDays);
            } else if (customXMin === null) {
                url.searchParams.delete('t');
            }
            // Add custom zoom ranges if set
            if (customXMin !== null) {
                url.searchParams.set('x', `${customXMin}.${customXMax}`);
                url.searchParams.delete('t');
            } else {
                url.searchParams.delete('x');
            }
            if (customYMin !== null) {
                url.searchParams.set('y', `${customYMin}.${customYMax}`);
            } else {
                url.searchParams.delete('y');
            }
            // Add line type if not default
            if (lineType !== 'raw') {
                url.searchParams.set('l', lineType);
            } else {
                url.searchParams.delete('l');
            }
            // Add state filter if not default
            if (stateFilter !== DEFAULT_STATE_FILTER) {
                url.searchParams.set('f', stateFilter);
            } else {
                url.searchParams.delete('f');
            }
            history.replaceState(null, '', url);
            saveToLocalStorage();
        }

        function saveToLocalStorage() {
            const statsWrapper = document.getElementById('stats-wrapper');
            const config = {
                selection: encodeSelection(),
                timeRange: timeRangeDays,
                lineType: lineType,
                stateFilter: stateFilter,
                statsHeight: statsWrapper ? statsWrapper.offsetHeight : 150
            };
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(config));
            } catch (e) {
                // Ignore storage errors
            }
        }

        function loadFromLocalStorage() {
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (!stored) return null;
                return JSON.parse(stored);
            } catch (e) {
                return null;
            }
        }

        function applyURLParams() {
            const params = new URLSearchParams(window.location.search);

            // Apply time range
            const t = params.get('t');
            if (t !== null) {
                const days = parseInt(t, 10);
                if (!isNaN(days) && VALID_TIME_RANGES.includes(days)) {
                    timeRangeDays = days;
                    document.getElementById('time-range').value = days;
                }
            }

            // Apply custom x range (overrides time range)
            const x = params.get('x');
            if (x) {
                const [xMin, xMax] = x.split('.').map(Number);
                if (!isNaN(xMin) && !isNaN(xMax)) {
                    customXMin = xMin;
                    customXMax = xMax;
                    document.getElementById('time-range').value = 'custom';
                    document.getElementById('btn-reset-zoom').style.display = '';
                }
            }

            // Apply custom y range
            const y = params.get('y');
            if (y) {
                const [yMin, yMax] = y.split('.').map(Number);
                if (!isNaN(yMin) && !isNaN(yMax)) {
                    customYMin = yMin;
                    customYMax = yMax;
                }
            }

            // Apply line type
            const l = params.get('l');
            if (l !== null && VALID_LINE_TYPES.includes(l)) {
                lineType = l;
                document.getElementById('line-type').value = l;
            }

            // Apply state filter
            const f = params.get('f');
            if (f !== null && VALID_STATE_FILTERS.includes(f)) {
                stateFilter = f;
                document.getElementById('state-filter').value = f;
            }

            // Apply selection
            const sel = decodeSelection(params.get('s'));
            if (!sel) return false;

            selectedJobs.clear();
            for (const { platform, type } of sel.matrix) {
                const jobs = jobMatrix[platform]?.[type] || [];
                for (const { name } of jobs) selectedJobs.add(name);
            }
            for (const group of sel.special) {
                const jobs = specialJobGroups[group] || [];
                for (const { name } of jobs) selectedJobs.add(name);
            }
            for (const idx of sel.indices) {
                if (jobNameList[idx]) selectedJobs.add(jobNameList[idx]);
            }
            return sel.matrix.length > 0 || sel.special.length > 0 || sel.indices.length > 0;
        }

        function setTimeRange(days) {
            timeRangeDays = parseInt(days, 10);
            // Clear custom zoom when selecting a preset
            clearCustomZoom();
            updateChart();
            updateStatsTable();
            updateURL();
        }

        function clearCustomZoom() {
            customXMin = null;
            customXMax = null;
            customYMin = null;
            customYMax = null;
            const select = document.getElementById('time-range');
            select.value = timeRangeDays;
            document.getElementById('btn-reset-zoom').style.display = 'none';
        }

        function setCustomZoom(xMin, xMax, yMin, yMax) {
            customXMin = xMin;
            customXMax = xMax;
            customYMin = yMin;
            customYMax = yMax;
            // Update dropdown to show "Custom"
            const select = document.getElementById('time-range');
            select.value = 'custom';
            document.getElementById('btn-reset-zoom').style.display = '';
            updateURL();
        }

        function handleZoomPanComplete({ chart }) {
            const xAxis = chart.scales.x;
            const yAxis = chart.scales.y;
            setCustomZoom(
                Math.round(xAxis.min),
                Math.round(xAxis.max),
                Math.round(yAxis.min),
                Math.round(yAxis.max)
            );
        }

        function resetZoom() {
            clearCustomZoom();
            updateChart();
            updateURL();
        }

        function setLineType(type) {
            lineType = type;
            updateChart();
            updateURL();
        }

        function setStateFilter(state) {
            stateFilter = state;
            updateChart();
            updateStatsTable();
            updateURL();
        }

        function getTimeRangeCutoff() {
            if (timeRangeDays === 0) return null;  // All time
            const cutoff = new Date();
            cutoff.setDate(cutoff.getDate() - timeRangeDays);
            return cutoff;
        }

        function classifyJob(name) {
            const lower = name.toLowerCase();
            if (lower.includes('juliasyntax')) return { group: 'juliasyntax', type: 'test' };
            if (lower.includes('launch')) return { group: 'pipeline', type: 'pipeline' };
            if (lower.includes('unlock')) return { group: 'pipeline', type: 'pipeline' };
            if (lower.includes('upload test results')) return { group: 'upload-results', type: 'upload' };
            if (lower.includes('upload docs')) return { group: 'docs', type: 'upload' };
            if (lower.includes('doctest') || lower.includes('pdf_docs')) return { group: 'docs', type: 'test' };

            // Platform-based grouping
            if (lower.includes(':linux:') || lower.includes('linux')) {
                if (lower.includes('coverage')) return { group: 'linux', type: 'coverage' };
                if (lower.includes('build')) return { group: 'linux', type: 'build' };
                if (lower.includes('test')) return { group: 'linux', type: 'test' };
                if (lower.includes('upload')) return { group: 'linux', type: 'upload' };
            }
            if (lower.includes(':macos:') || lower.includes('macos') || lower.includes('darwin')) {
                if (lower.includes('coverage')) return { group: 'macos', type: 'coverage' };
                if (lower.includes('build')) return { group: 'macos', type: 'build' };
                if (lower.includes('test')) return { group: 'macos', type: 'test' };
                if (lower.includes('upload')) return { group: 'macos', type: 'upload' };
            }
            if (lower.includes(':windows:') || lower.includes('windows') || lower.includes('mingw')) {
                if (lower.includes('coverage')) return { group: 'windows', type: 'coverage' };
                if (lower.includes('build')) return { group: 'windows', type: 'build' };
                if (lower.includes('test')) return { group: 'windows', type: 'test' };
                if (lower.includes('upload')) return { group: 'windows', type: 'upload' };
            }
            if (lower.includes(':freebsd:') || lower.includes('freebsd')) {
                if (lower.includes('coverage')) return { group: 'freebsd', type: 'coverage' };
                if (lower.includes('build')) return { group: 'freebsd', type: 'build' };
                if (lower.includes('test')) return { group: 'freebsd', type: 'test' };
                if (lower.includes('upload')) return { group: 'freebsd', type: 'upload' };
            }

            // Special test types
            if (['asan', 'tsan', 'analyzegc', 'llvmpasses', 'embedding', 'gcext', 'trimming'].includes(lower)) {
                return { group: 'special', type: 'test' };
            }
            if (lower === 'test revise') return { group: 'special', type: 'test' };

            return { group: 'other', type: 'other' };
        }

        // Compute temporal moving average over windowDays
        function computeMovingAverage(points, windowDays) {
            if (points.length === 0) return [];
            const windowMs = windowDays * 24 * 60 * 60 * 1000;
            const result = [];

            for (let i = 0; i < points.length; i++) {
                const centerDate = points[i].x.getTime();
                const windowStart = centerDate - windowMs / 2;
                const windowEnd = centerDate + windowMs / 2;

                let sum = 0;
                let count = 0;
                for (const pt of points) {
                    const t = pt.x.getTime();
                    if (t >= windowStart && t <= windowEnd) {
                        sum += pt.y;
                        count++;
                    }
                }

                result.push({
                    x: points[i].x,
                    y: count > 0 ? sum / count : points[i].y,
                    meta: points[i].meta
                });
            }
            return result;
        }

        function updateChart() {
            const selectedArray = Array.from(selectedJobs);
            if (selectedArray.length === 0) {
                if (chart) chart.destroy();
                chart = null;
                chartMetadata = {};
                return;
            }

            // Build datasets and metadata
            const datasets = [];
            chartMetadata = {};
            const cutoff = getTimeRangeCutoff();

            for (const jobName of selectedArray) {
                const jobData = data.jobs[jobName];
                if (!jobData) continue;

                const color = jobColors[jobName];
                const points = [];

                for (const run of jobData.recent) {
                    const date = new Date(run.date);
                    if (cutoff && date < cutoff) continue;
                    const runState = getRunState(run);
                    if (stateFilter === 'passed' && runState !== 'passed') continue;
                    if (stateFilter === 'failed' && !isFailedState(runState)) continue;
                    points.push({
                        x: date,
                        y: run.duration,
                        state: runState,
                        meta: {
                            job: jobName,
                            commit: run.commit,
                            build: run.build,
                            date: run.date,
                            duration: run.duration,
                            message: run.message,
                            author: run.author,
                            state: runState,
                            agent: run.agent || ''
                        }
                    });
                }

                if (points.length === 0) continue;  // Skip jobs with no data in range

                // Sort by date
                points.sort((a, b) => a.x - b.x);

                // Apply moving average if selected
                const smoothedPoints = lineType === 'raw' ? points :
                    computeMovingAverage(points, parseInt(lineType, 10));

                // Build metadata from raw points
                const datasetIdx = datasets.length;
                points.forEach((pt, idx) => {
                    chartMetadata[`${datasetIdx}-${idx}`] = pt.meta;
                });

                // Create custom canvas for timed_out marker (‚§í) at high DPI
                const createTimedOutMarker = (fillColor) => {
                    const scale = window.devicePixelRatio || 2;
                    const size = 10;
                    const canvas = document.createElement('canvas');
                    canvas.width = size * scale;
                    canvas.height = size * scale;
                    canvas.style.width = size + 'px';
                    canvas.style.height = size + 'px';
                    const ctx = canvas.getContext('2d');
                    ctx.scale(scale, scale);
                    ctx.strokeStyle = fillColor;
                    ctx.fillStyle = fillColor;
                    ctx.lineWidth = 1.0;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    const cx = size / 2;
                    const cy = size / 2;
                    // Horizontal bar at center
                    ctx.beginPath();
                    ctx.moveTo(cx - 1.5, cy);
                    ctx.lineTo(cx + 1.5, cy);
                    ctx.stroke();
                    // Vertical line (stem) - from center down
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx, cy + 4);
                    ctx.stroke();
                    // Arrow head just below the bar
                    ctx.beginPath();
                    ctx.moveTo(cx - 1.5, cy + 2.5);
                    ctx.lineTo(cx, cy);
                    ctx.lineTo(cx + 1.5, cy + 2.5);
                    ctx.stroke();
                    return canvas;
                };
                const timedOutMarker = createTimedOutMarker(color);

                // Generate point styles based on state
                const getPointStyle = (state) => {
                    if (state === 'timed_out') return timedOutMarker;
                    if (state === 'failed' || state === 'canceled') return 'crossRot';
                    return 'circle';
                };
                const pointStyles = points.map(p => getPointStyle(p.state));
                const pointRadii = points.map(p => isFailedState(p.state) ? 5 : 2);

                if (lineType === 'raw') {
                    // Single dataset with line and points
                    datasets.push({
                        label: jobName,
                        data: points.map(p => ({ x: p.x, y: p.y })),
                        borderColor: color,
                        borderWidth: 1.5,
                        backgroundColor: color + '20',
                        fill: false,
                        tension: 0.2,
                        pointRadius: pointRadii,
                        pointHoverRadius: 3,
                        pointBackgroundColor: color,
                        pointBorderColor: color,
                        pointStyle: pointStyles,
                        spanGaps: true
                    });
                } else {
                    // Two datasets: smoothed line + raw points
                    // Line dataset (no points)
                    datasets.push({
                        label: jobName,
                        data: smoothedPoints.map(p => ({ x: p.x, y: p.y })),
                        borderColor: color,
                        borderWidth: 1.5,
                        backgroundColor: color + '20',
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        spanGaps: true
                    });
                    // Points dataset (raw values, no line)
                    datasets.push({
                        label: jobName + ' (points)',
                        data: points.map(p => ({ x: p.x, y: p.y })),
                        borderColor: color,
                        backgroundColor: color,
                        fill: false,
                        showLine: false,
                        pointRadius: pointRadii,
                        pointHoverRadius: 3,
                        pointStyle: pointStyles,
                        pointBorderColor: color,
                        pointBackgroundColor: color
                    });
                    // Also track metadata for points dataset
                    points.forEach((pt, idx) => {
                        chartMetadata[`${datasetIdx + 1}-${idx}`] = pt.meta;
                    });
                }
            }

            if (chart) chart.destroy();

            const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const gridColor = isDark ? '#30363d' : '#d0d7de';
            const textColor = isDark ? '#8b949e' : '#656d76';

            const ctx = document.getElementById('timing-chart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    interaction: {
                        mode: 'nearest',
                        intersect: true
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'xy',
                                modifierKey: null,
                                onPanComplete: handleZoomPanComplete
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                    modifierKey: null
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: 'rgba(9, 105, 218, 0.2)',
                                    borderColor: 'rgba(9, 105, 218, 0.8)',
                                    borderWidth: 1
                                },
                                mode: 'xy',
                                onZoomComplete: handleZoomPanComplete
                            }
                        },
                        tooltip: {
                            borderWidth: 3,
                            borderColor: (ctx) => {
                                if (ctx.tooltip?.dataPoints?.length > 0) {
                                    const dp = ctx.tooltip.dataPoints[0];
                                    // Get the actual line color
                                    const color = dp.dataset.borderColor !== 'transparent'
                                        ? dp.dataset.borderColor
                                        : dp.dataset.backgroundColor;
                                    return color;
                                }
                                return 'transparent';
                            },
                            callbacks: {
                                title: (items) => {
                                    if (items.length === 0) return '';
                                    const ctx = items[0];
                                    // Strip " (points)" suffix from label
                                    const label = ctx.dataset.label.replace(' (points)', '');
                                    return convertEmojiText(label);
                                },
                                label: (ctx) => {
                                    // Only show details for point datasets (pointRadius > 0)
                                    if (ctx.dataset.pointRadius === 0) return null;
                                    const key = `${ctx.datasetIndex}-${ctx.dataIndex}`;
                                    const meta = chartMetadata[key];
                                    if (!meta) return null;
                                    const getStateDisplay = (state) => {
                                        if (state === 'timed_out') return '‚§í timed out';
                                        if (state === 'failed') return '‚ùå failed';
                                        if (state === 'canceled') return '‚ùå canceled';
                                        if (state === 'passed') return '‚úì passed';
                                        return state || '';
                                    };
                                    const lines = [
                                        `${getStateDisplay(meta.state)} ¬∑ ${formatDuration(ctx.parsed.y)}`,
                                        meta.message || ''
                                    ];
                                    if (meta?.agent) lines.push(`üñ•Ô∏è ${meta.agent}`);
                                    return lines.filter(Boolean);
                                },
                                labelColor: (ctx) => {
                                    // Use actual color (not transparent for points dataset)
                                    const color = ctx.dataset.backgroundColor !== 'transparent'
                                        ? ctx.dataset.backgroundColor
                                        : ctx.dataset.borderColor;
                                    return {
                                        borderColor: color,
                                        backgroundColor: color
                                    };
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            min: customXMin || undefined,
                            max: customXMax || undefined,
                            time: {
                                displayFormats: {
                                    day: 'MMM d',
                                    week: 'MMM d',
                                    month: 'MMM yyyy'
                                }
                            },
                            ticks: {
                                color: textColor,
                                maxRotation: 45,
                                callback: function(value, index, ticks) {
                                    const date = new Date(value);
                                    const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                                    const label = `${months[date.getMonth()]} ${date.getDate()}`;
                                    // Show year on first tick and when year changes
                                    if (index === 0) {
                                        return `${label} '${date.getFullYear().toString().slice(-2)}`;
                                    }
                                    const prevDate = index > 0 ? new Date(ticks[index - 1].value) : null;
                                    if (prevDate && prevDate.getFullYear() !== date.getFullYear()) {
                                        return `${label} '${date.getFullYear().toString().slice(-2)}`;
                                    }
                                    return label;
                                }
                            },
                            grid: { color: gridColor },
                            afterBuildTicks: (axis) => {
                                const rangeMs = axis.max - axis.min;
                                const DAY = 24 * 60 * 60 * 1000;
                                // Nice intervals: 1w, 2w, 1mo
                                const niceSteps = [7*DAY, 14*DAY, 30*DAY];
                                let step = niceSteps.find(s => rangeMs / s <= 12) || 30*DAY;

                                // Round min to start of day
                                const minDate = new Date(axis.min);
                                minDate.setHours(0, 0, 0, 0);
                                let minTick = minDate.getTime();
                                // Align to week boundary (Sunday)
                                const dayOfWeek = minDate.getDay();
                                minTick -= dayOfWeek * DAY;
                                // Move to first tick after axis.min
                                while (minTick < axis.min) minTick += step;

                                const ticks = [];
                                for (let v = minTick; v <= axis.max; v += step) {
                                    ticks.push({ value: v });
                                }
                                if (ticks.length > 0) axis.ticks = ticks;
                            }
                        },
                        y: {
                            min: customYMin || undefined,
                            max: customYMax || undefined,
                            ticks: {
                                color: textColor,
                                callback: (v) => formatDuration(v),
                                // Use nice intervals: 1m, 2m, 5m, 10m, 15m, 30m, 1h, 2h
                                autoSkip: true,
                                maxTicksLimit: 10
                            },
                            grid: { color: gridColor },
                            afterBuildTicks: (axis) => {
                                const range = axis.max - axis.min;
                                // Pick step size for nice round numbers
                                const niceSteps = [60, 120, 300, 600, 900, 1800, 3600, 7200];
                                let step = niceSteps.find(s => range / s <= 10) || 7200;
                                const minTick = Math.ceil(axis.min / step) * step;
                                const ticks = [];
                                for (let v = minTick; v <= axis.max; v += step) {
                                    ticks.push({ value: v });
                                }
                                axis.ticks = ticks;
                            }
                        }
                    },
                    onClick: (evt, elements) => {
                        if (elements.length > 0) {
                            const el = elements[0];
                            const key = `${el.datasetIndex}-${el.index}`;
                            const meta = chartMetadata[key];
                            if (meta) showPopup(meta);
                        }
                    }
                }
            });
        }

        function showPopup(meta) {
            document.getElementById('popup-job').innerHTML = convertEmoji(meta.job);
            const state = meta.state || 'passed';
            const stateEl = document.getElementById('popup-state');
            const failed = isFailedState(state);
            const stateIcon = failed ? '‚ùå' : '‚úÖ';
            const stateText = state === 'timed_out' ? 'timed out' : state;
            stateEl.innerHTML = `${stateIcon} ${stateText}`;
            stateEl.style.color = failed ? 'var(--color-danger-fg)' :
                                  state === 'passed' ? 'var(--color-success-fg)' : 'inherit';
            document.getElementById('popup-duration').textContent = formatDuration(meta.duration);
            document.getElementById('popup-agent').textContent = meta.agent || '(unknown)';
            document.getElementById('popup-date').textContent = meta.date;
            document.getElementById('popup-commit').textContent = meta.commit;
            document.getElementById('popup-message').textContent = meta.message || '(no message)';
            document.getElementById('popup-author').textContent = meta.author || '(unknown)';
            document.getElementById('popup-build').textContent = `#${meta.build}`;

            document.getElementById('popup-github-link').href =
                `https://github.com/JuliaLang/julia/commit/${meta.commit}`;

            // Use stored pipeline, with fallback heuristic for old data
            const pipeline = meta.pipeline || 
                (meta.job.toLowerCase().includes('coverage') || meta.job.toLowerCase().includes('srcassert') 
                    ? 'julia-master-scheduled' : 'julia-master');
            document.getElementById('popup-buildkite-link').href =
                `https://buildkite.com/julialang/${pipeline}/builds/${meta.build}`;

            document.getElementById('popup-overlay').classList.add('visible');
        }

        function closePopup(event) {
            if (event.target.id === 'popup-overlay') {
                document.getElementById('popup-overlay').classList.remove('visible');
            }
        }

        // Resizable stats panel
        (function() {
            const handle = document.getElementById('resize-handle');
            const wrapper = document.getElementById('stats-wrapper');
            let startY, startHeight;

            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startY = e.clientY;
                startHeight = wrapper.offsetHeight;
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                document.body.style.cursor = 'ns-resize';
                document.body.style.userSelect = 'none';
            });

            function onMouseMove(e) {
                const delta = startY - e.clientY;
                const newHeight = Math.max(50, Math.min(window.innerHeight * 0.7, startHeight + delta));
                wrapper.style.height = newHeight + 'px';
            }

            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                // Save to localStorage
                saveToLocalStorage();
            }

            // Touch support
            handle.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                startY = touch.clientY;
                startHeight = wrapper.offsetHeight;
                document.addEventListener('touchmove', onTouchMove);
                document.addEventListener('touchend', onTouchEnd);
            });

            function onTouchMove(e) {
                const touch = e.touches[0];
                const delta = startY - touch.clientY;
                const newHeight = Math.max(50, Math.min(window.innerHeight * 0.7, startHeight + delta));
                wrapper.style.height = newHeight + 'px';
            }

            function onTouchEnd() {
                document.removeEventListener('touchmove', onTouchMove);
                document.removeEventListener('touchend', onTouchEnd);
                saveToLocalStorage();
            }
        })();

        // Close popup on Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                document.getElementById('popup-overlay').classList.remove('visible');
            }
        });

        function updateStatsTable() {
            const tbody = document.getElementById('stats-tbody');
            tbody.innerHTML = '';

            if (selectedJobs.size === 0) {
                tbody.innerHTML = '<tr><td colspan="9" class="loading">Select jobs to see statistics</td></tr>';
                updateSortIndicators();
                return;
            }

            const cutoff = getTimeRangeCutoff();

            // First, compute all stats for each job
            const jobStats = [];
            for (const jobName of selectedJobs) {
                const job = data.jobs[jobName];
                if (!job) continue;

                const filtered = filterRunsByState(job.recent, cutoff);
                if (filtered.length === 0) continue;

                const durations = filtered.map(r => r.duration);
                const sorted = [...durations].sort((a, b) => a - b);
                const median = sorted[Math.floor(sorted.length / 2)];
                const mean = durations.reduce((a, b) => a + b, 0) / durations.length;
                const min = Math.min(...durations);
                const max = Math.max(...durations);
                const variance = durations.reduce((sum, d) => sum + (d - mean) ** 2, 0) / durations.length;
                const std = Math.sqrt(variance);
                const trend = computeTrend(filtered);
                const pr = jobPassRates[jobName];

                jobStats.push({
                    jobName,
                    color: jobColors[jobName],
                    median,
                    mean,
                    min,
                    max,
                    std,
                    trend,
                    pr,
                    n: filtered.length
                });
            }

            // Sort based on current sort column
            jobStats.sort((a, b) => {
                let cmp = 0;
                switch (statsTableSortColumn) {
                    case 'job':
                        cmp = a.jobName.localeCompare(b.jobName);
                        break;
                    case 'passRate':
                        const prA = a.pr?.rate ?? 1;
                        const prB = b.pr?.rate ?? 1;
                        cmp = prA - prB;
                        break;
                    case 'median':
                        cmp = a.median - b.median;
                        break;
                    case 'mean':
                        cmp = a.mean - b.mean;
                        break;
                    case 'min':
                        cmp = a.min - b.min;
                        break;
                    case 'max':
                        cmp = a.max - b.max;
                        break;
                    case 'std':
                        cmp = a.std - b.std;
                        break;
                    case 'trend':
                        // Sort by: significant positive (worst) ‚Üí flat ‚Üí significant negative (best)
                        // Tier: 1 = significant positive, 0 = flat/not significant, -1 = significant negative
                        const getTrendTier = (t) => {
                            if (!t || !t.significant) return 0;  // flat
                            return t.percentChange > 0 ? 1 : -1;
                        };
                        const tierA = getTrendTier(a.trend);
                        const tierB = getTrendTier(b.trend);
                        if (tierA !== tierB) {
                            cmp = tierA - tierB;
                        } else {
                            // Within same tier, sort by magnitude
                            const pctA = a.trend?.percentChange ?? 0;
                            const pctB = b.trend?.percentChange ?? 0;
                            cmp = pctA - pctB;
                        }
                        break;
                    case 'n':
                        cmp = a.n - b.n;
                        break;
                }
                return statsTableSortAsc ? cmp : -cmp;
            });

            // Render rows
            for (const stat of jobStats) {
                const { jobName, color, median, mean, min, max, std, trend, pr, n } = stat;

                let passRateHtml = '<span style="color: var(--color-fg-muted)">‚Äî</span>';
                if (pr && pr.total > 0) {
                    const pct = Math.round(pr.rate * 100);
                    const isLow = pr.total >= PASS_RATE_MIN_RUNS && pr.rate < PASS_RATE_THRESHOLD;
                    const prColor = isLow ? 'var(--color-danger-fg)' : (pr.rate < 1 ? 'var(--color-attention-fg)' : 'var(--color-success-fg)');
                    const icon = isLow ? '‚ö†Ô∏è ' : '';
                    const parts = [];
                    if (pr.failed > 0) parts.push(`${pr.failed} failed`);
                    if (pr.timedOut > 0) parts.push(`${pr.timedOut} timed out`);
                    if (pr.canceled > 0) parts.push(`${pr.canceled} canceled`);
                    const breakdown = parts.length > 0 ? parts.join(', ') : 'all passed';
                    passRateHtml = `<span style="color: ${prColor}" title="${breakdown} out of ${pr.total} in last ${PASS_RATE_DAYS} days">${icon}${pct}%</span>`;
                }

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><span class="color-dot" style="background: ${color}"></span> ${convertEmoji(jobName)}</td>
                    <td>${passRateHtml}</td>
                    <td class="duration">${formatDuration(median)}</td>
                    <td class="duration">${formatDuration(mean)}</td>
                    <td class="duration">${formatDuration(min)}</td>
                    <td class="duration">${formatDuration(max)}</td>
                    <td class="duration">¬±${formatDuration(std)}</td>
                    <td>${formatTrend(trend)}</td>
                    <td>${n}</td>
                `;
                tbody.appendChild(row);
            }

            updateSortIndicators();
        }

        function updateSortIndicators() {
            const headers = document.querySelectorAll('.stats-bar th.sortable');
            headers.forEach(th => {
                const col = th.dataset.sort;
                const indicator = th.querySelector('.sort-indicator');
                if (col === statsTableSortColumn) {
                    th.classList.add('sorted');
                    indicator.textContent = statsTableSortAsc ? '‚ñ≤' : '‚ñº';
                } else {
                    th.classList.remove('sorted');
                    indicator.textContent = '‚ñ≤';
                }
            });
        }

        function handleStatsTableSort(column) {
            if (statsTableSortColumn === column) {
                statsTableSortAsc = !statsTableSortAsc;
            } else {
                statsTableSortColumn = column;
                statsTableSortAsc = column === 'job';  // Job defaults to ascending, others to descending
            }
            updateStatsTable();
        }

        function toggleJobItem(item, jobName) {
            if (selectedJobs.has(jobName)) {
                selectedJobs.delete(jobName);
                item.classList.remove('selected');
            } else {
                selectedJobs.add(jobName);
                item.classList.add('selected');
            }
            refreshAllUI();
            updateURL();
        }

        function updateToolbarButtons() {
            const total = Object.keys(data.jobs).length;
            const selected = selectedJobs.size;
            document.getElementById('btn-all').classList.toggle('primary', selected === total);
            document.getElementById('btn-none').classList.toggle('primary', selected === 0);
        }

        function selectAllJobs() {
            for (const name of Object.keys(data.jobs)) {
                selectedJobs.add(name);
            }
            syncJobListUI();
            refreshAllUI();
            updateURL();
        }

        function deselectAllJobs() {
            selectedJobs.clear();
            syncJobListUI();
            refreshAllUI();
            updateURL();
        }

        // Matrix organization
        const platformOrder = ['linux', 'macos', 'windows', 'freebsd'];
        const typeOrder = ['build', 'test', 'upload', 'coverage'];
        const platformLabels = {
            'linux': `<img src="${BUILDKITE_EMOJI_BASE}/linux.png" class="bk-emoji"> Linux`,
            'macos': `<img src="${BUILDKITE_EMOJI_BASE}/mac.png" class="bk-emoji"> macOS`,
            'windows': `<img src="${BUILDKITE_EMOJI_BASE}/windows.png" class="bk-emoji"> Windows`,
            'freebsd': `<img src="${BUILDKITE_EMOJI_BASE}/freebsd.png" class="bk-emoji"> FreeBSD`
        };
        const typeLabels = {
            'build': 'Build',
            'test': 'Test',
            'upload': 'Upload',
            'coverage': 'Coverage'
        };
        const specialGroups = ['juliasyntax', 'docs', 'special', 'pipeline', 'upload-results', 'other'];
        const specialLabels = {
            'juliasyntax': 'üìù JuliaSyntax',
            'docs': 'üìö Docs',
            'special': 'üî¨ Special',
            'pipeline': '‚öôÔ∏è Pipeline',
            'upload-results': 'üì§ Results',
            'other': 'üì¶ Other'
        };

        // Job matrix data: matrix[platform][type] = [jobs]
        let jobMatrix = {};
        let specialJobGroups = {};

        function buildJobMatrix() {
            jobMatrix = {};
            specialJobGroups = {};

            for (const platform of platformOrder) {
                jobMatrix[platform] = {};
                for (const type of typeOrder) {
                    jobMatrix[platform][type] = [];
                }
            }
            for (const group of specialGroups) {
                specialJobGroups[group] = [];
            }

            for (const [name, job] of Object.entries(data.jobs)) {
                const { group, type } = classifyJob(name);
                if (platformOrder.includes(group) && typeOrder.includes(type)) {
                    jobMatrix[group][type].push({ name, job });
                } else if (specialGroups.includes(group)) {
                    specialJobGroups[group].push({ name, job });
                } else {
                    specialJobGroups['other'].push({ name, job });
                }
            }
        }

        function populateJobSelector() {
            buildJobMatrix();
            buildJobIndex();

            // Assign colors
            const allJobs = Object.keys(data.jobs);
            const colors = generateColors(allJobs.length);
            allJobs.forEach((name, i) => {
                jobColors[name] = colors[i];
            });

            // Calculate pass rates for all jobs
            calculateAllPassRates();

            // Build matrix table
            const matrixContainer = document.getElementById('job-matrix');
            let html = '<table class="matrix-table">';

            // Header row
            html += '<tr><th class="matrix-corner clickable" onclick="selectAllMatrix()" title="Select all matrix jobs"></th>';
            for (const type of typeOrder) {
                html += `<th class="clickable" onclick="selectByType('${type}')">${typeLabels[type]}</th>`;
            }
            html += '</tr>';

            // Platform rows
            for (const platform of platformOrder) {
                html += `<tr><th class="row-header clickable" onclick="selectByPlatform('${platform}')">${platformLabels[platform]}</th>`;
                for (const type of typeOrder) {
                    const jobs = jobMatrix[platform][type];
                    const count = jobs.length;
                    // Check if any job in this cell has low pass rate
                    const hasIssue = jobs.some(({ name }) => {
                        const pr = jobPassRates[name];
                        return pr && pr.total >= PASS_RATE_MIN_RUNS && pr.rate < PASS_RATE_THRESHOLD;
                    });
                    html += `<td class="matrix-cell" data-platform="${platform}" data-type="${type}" onclick="toggleMatrixCell('${platform}', '${type}')">`;
                    if (count > 0) {
                        html += `<span class="job-count">${count}</span>`;
                        if (hasIssue) html += '<span class="failure-indicator">‚ö†Ô∏è</span>';
                    } else {
                        html += '-';
                    }
                    html += '</td>';
                }
                html += '</tr>';
            }

            // Special groups row
            html += '<tr><th class="row-header clickable" colspan="5" style="text-align:center; padding-top:8px;" onclick="selectAllSpecial()" title="Toggle all special jobs">Special</th></tr>';
            html += '<tr><td colspan="5" style="padding:0;">';
            html += '<div style="display:flex; flex-wrap:wrap; gap:4px; padding:8px; justify-content:center;">';
            for (const group of specialGroups) {
                const jobs = specialJobGroups[group];
                if (jobs.length > 0) {
                    const hasIssue = jobs.some(({ name }) => {
                        const pr = jobPassRates[name];
                        return pr && pr.total >= PASS_RATE_MIN_RUNS && pr.rate < PASS_RATE_THRESHOLD;
                    });
                    const warnIcon = hasIssue ? ' ‚ö†Ô∏è' : '';
                    html += `<button class="btn" style="font-size:10px; padding:3px 8px;" data-special="${group}" onclick="toggleSpecialGroup('${group}')">${specialLabels[group]} (${jobs.length})${warnIcon}</button>`;
                }
            }
            html += '</div></td></tr>';

            html += '</table>';
            matrixContainer.innerHTML = html;

            // Build job list
            const listContainer = document.getElementById('job-list');
            listContainer.innerHTML = '';

            // Apply URL params (selection and time range) or localStorage or default
            const hasURLSelection = applyURLParams();
            if (!hasURLSelection) {
                // Try localStorage
                const stored = loadFromLocalStorage();
                if (stored) {
                    // Apply stored time range
                    if (stored.timeRange !== undefined && [0, 7, 14, 30, 60, 90].includes(stored.timeRange)) {
                        timeRangeDays = stored.timeRange;
                        document.getElementById('time-range').value = stored.timeRange;
                    }
                    // Apply stored line type
                    if (stored.lineType && ['raw', '7', '30', '90'].includes(stored.lineType)) {
                        lineType = stored.lineType;
                        document.getElementById('line-type').value = stored.lineType;
                    }
                    // Apply stored state filter
                    if (stored.stateFilter && ['all', 'passed', 'failed'].includes(stored.stateFilter)) {
                        stateFilter = stored.stateFilter;
                        document.getElementById('state-filter').value = stored.stateFilter;
                    }
                    // Apply stored stats panel height
                    if (stored.statsHeight && stored.statsHeight >= 50) {
                        document.getElementById('stats-wrapper').style.height = stored.statsHeight + 'px';
                    }
                    // Apply stored selection
                    const sel = decodeSelection(stored.selection);
                    if (sel && (sel.matrix.length > 0 || sel.special.length > 0 || sel.indices.length > 0)) {
                        for (const { platform, type } of sel.matrix) {
                            const jobs = jobMatrix[platform]?.[type] || [];
                            for (const { name } of jobs) selectedJobs.add(name);
                        }
                        for (const group of sel.special) {
                            const jobs = specialJobGroups[group] || [];
                            for (const { name } of jobs) selectedJobs.add(name);
                        }
                        for (const idx of sel.indices) {
                            if (jobNameList[idx]) selectedJobs.add(jobNameList[idx]);
                        }
                    }
                }
                // If still nothing selected, select all platform jobs by default
                if (selectedJobs.size === 0) {
                    for (const platform of platformOrder) {
                        for (const type of typeOrder) {
                            for (const { name } of (jobMatrix[platform]?.[type] || [])) {
                                selectedJobs.add(name);
                            }
                        }
                    }
                }
            }

            const getLatestDuration = (job) => job.recent?.[0]?.duration ?? 0;

            const allJobsSorted = Object.entries(data.jobs)
                .map(([name, job]) => ({ name, job }))
                .sort((a, b) => getLatestDuration(b.job) - getLatestDuration(a.job));

            for (const { name, job } of allJobsSorted) {
                const color = jobColors[name];
                const pr = jobPassRates[name];
                const showWarning = pr && pr.total >= PASS_RATE_MIN_RUNS && pr.rate < PASS_RATE_THRESHOLD;
                const item = document.createElement('div');
                item.className = 'job-item' + (selectedJobs.has(name) ? ' selected' : '');
                item.dataset.job = name;
                item.onclick = () => toggleJobItem(item, name);
                let passRateHtml = '';
                if (showWarning) {
                    const pct = Math.round(pr.rate * 100);
                    const parts = [];
                    if (pr.failed > 0) parts.push(`${pr.failed} failed`);
                    if (pr.timedOut > 0) parts.push(`${pr.timedOut} timed out`);
                    passRateHtml = `<span class="failure-rate" title="${parts.join(', ')} in last ${PASS_RATE_DAYS} days">‚ö†Ô∏è ${pct}%</span>`;
                }
                const latestDuration = getLatestDuration(job);
                item.innerHTML = `
                    <span class="color-dot" style="background: ${color}"></span>
                    <span class="job-name">${convertEmoji(name)}</span>
                    ${passRateHtml}
                    <span class="job-median" title="Latest run">${formatDuration(latestDuration)}</span>
                `;
                listContainer.appendChild(item);
            }

            refreshAllUI();
        }

        function updateMatrixHighlights() {
            // Update platform/type cells
            for (const platform of platformOrder) {
                for (const type of typeOrder) {
                    const cell = document.querySelector(`.matrix-cell[data-platform="${platform}"][data-type="${type}"]`);
                    if (!cell) continue;
                    const jobs = jobMatrix[platform][type];
                    const selectedCount = jobs.filter(j => selectedJobs.has(j.name)).length;
                    cell.classList.remove('has-selection', 'partial-selection');
                    if (selectedCount === jobs.length && jobs.length > 0) {
                        cell.classList.add('has-selection');
                    } else if (selectedCount > 0) {
                        cell.classList.add('partial-selection');
                    }
                }
            }

            // Update special group buttons
            for (const group of specialGroups) {
                const btn = document.querySelector(`button[data-special="${group}"]`);
                if (!btn) continue;
                const jobs = specialJobGroups[group];
                const selectedCount = jobs.filter(j => selectedJobs.has(j.name)).length;
                btn.classList.remove('primary');
                if (selectedCount === jobs.length && jobs.length > 0) {
                    btn.classList.add('primary');
                }
            }
        }

        function updateJobCount() {
            const total = Object.keys(data.jobs).length;
            document.getElementById('job-count').textContent = `${selectedJobs.size}/${total}`;
        }

        function toggleMatrixCell(platform, type) {
            toggleJobsSelection(jobMatrix[platform][type]);
            syncJobListUI();
            refreshAllUI();
            updateURL();
        }

        function selectByPlatform(platform) {
            const jobs = [];
            for (const type of typeOrder) {
                jobs.push(...jobMatrix[platform][type]);
            }
            toggleJobsSelection(jobs);
            syncJobListUI();
            refreshAllUI();
            updateURL();
        }

        function selectAllMatrix() {
            const jobs = [];
            for (const platform of platformOrder) {
                for (const type of typeOrder) {
                    jobs.push(...jobMatrix[platform][type]);
                }
            }
            toggleJobsSelection(jobs);
            syncJobListUI();
            refreshAllUI();
            updateURL();
        }

        function selectAllSpecial() {
            const jobs = [];
            for (const group of specialGroups) {
                jobs.push(...(specialJobGroups[group] || []));
            }
            toggleJobsSelection(jobs);
            syncJobListUI();
            refreshAllUI();
            updateURL();
        }

        function selectByType(type) {
            const jobs = [];
            for (const platform of platformOrder) {
                jobs.push(...jobMatrix[platform][type]);
            }
            toggleJobsSelection(jobs);
            syncJobListUI();
            refreshAllUI();
            updateURL();
        }

        function toggleSpecialGroup(group) {
            toggleJobsSelection(specialJobGroups[group]);
            syncJobListUI();
            refreshAllUI();
            updateURL();
        }

        function syncJobListUI() {
            document.querySelectorAll('.job-item').forEach(el => {
                el.classList.toggle('selected', selectedJobs.has(el.dataset.job));
            });
        }

        function timeAgo(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const seconds = Math.floor((now - date) / 1000);

            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            if (days < 7) return `${days}d ago`;
            const weeks = Math.floor(days / 7);
            return `${weeks}w ago`;
        }

        async function loadData() {
            try {
                // Render empty matrix skeleton immediately
                renderMatrixSkeleton();

                const resp = await fetch('data/timing_summary.json');
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

                // Stream and parse JSON progressively
                const reader = resp.body.getReader();
                const decoder = new TextDecoder();
                let jsonText = '';
                let jobCount = 0;
                let uiRendered = false;
                let lastProgressTime = 0;
                const PROGRESS_INTERVAL = 100; // ms between progress updates

                // Initialize data structure
                data = { jobs: {} };

                // Calculate cutoff date for early UI render based on default time range
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - DEFAULT_TIME_RANGE);
                const cutoffStr = cutoffDate.toISOString().slice(0, 10); // "yyyy-mm-dd"

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    jsonText += decoder.decode(value, { stream: true });

                    const now = performance.now();
                    if (now - lastProgressTime > PROGRESS_INTERVAL) {
                        // Extract generated_at if we haven't yet
                        if (!data.generated_at) {
                            const match = jsonText.match(/"generated_at":\s*"([^"]+)"/);
                            if (match) {
                                data.generated_at = match[1];
                                const updatedEl = document.getElementById('last-updated');
                                updatedEl.textContent = `Updated ${timeAgo(data.generated_at)}`;
                                updatedEl.title = data.generated_at;
                            }
                        }

                        // Count jobs to show progress
                        const jobMatches = jsonText.match(/":\s*\{\s*"recent"/g);
                        const newCount = jobMatches ? jobMatches.length : 0;
                        if (newCount > jobCount) {
                            jobCount = newCount;
                            document.getElementById('chart-loading').innerHTML =
                                `<span class="loading">Loading... ${jobCount} jobs</span>`;
                        }

                        // Try to render UI early once we have enough data for the default time range
                        if (!uiRendered && jobCount >= 5) {
                            // Check if we have data beyond the cutoff date (older data)
                            // The JSON has jobs sorted newest first, so look for dates older than cutoff
                            const hasOldEnoughData = jsonText.includes(`"date": "${cutoffStr}`) ||
                                                     jsonText.includes(`"date": "20`) && jsonText.lastIndexOf('"date":') > jsonText.length - 5000;

                            // Try a partial parse to see if we can render
                            if (hasOldEnoughData || jsonText.length > 500000) {
                                const partialData = tryParsePartialJSON(jsonText);
                                if (partialData && Object.keys(partialData.jobs).length >= 5) {
                                    data = partialData;
                                    populateJobSelector();
                                    document.getElementById('chart-loading').style.display = 'none';
                                    uiRendered = true;
                                }
                            }
                        }

                        lastProgressTime = now;
                    }
                }

                // Final parse
                jsonText += decoder.decode();
                data = JSON.parse(jsonText);

                const updatedEl = document.getElementById('last-updated');
                updatedEl.textContent = `Updated ${timeAgo(data.generated_at)}`;
                updatedEl.title = data.generated_at;

                if (!uiRendered) {
                    populateJobSelector();
                    document.getElementById('chart-loading').style.display = 'none';
                } else {
                    // Update with complete data - need to rebuild everything
                    // since we may have been missing jobs in partial parse
                    const currentSelection = new Set(selectedJobs);
                    populateJobSelector();
                    // Restore selection (populateJobSelector may have changed it)
                    selectedJobs = currentSelection;
                    refreshAllUI();
                }
            } catch (err) {
                console.error('Failed to load data:', err);
                document.getElementById('chart-loading').innerHTML = '<span class="error">Failed to load data</span>';
                document.getElementById('job-matrix').innerHTML = '<div class="error">Failed to load</div>';
                document.getElementById('job-list').innerHTML = '<div class="error">Failed to load jobs</div>';
                document.getElementById('stats-tbody').innerHTML = `
                    <tr><td colspan="7" class="error">
                        Failed to load data. Run <code>julia fetch_timing.jl</code> to generate data.
                    </td></tr>
                `;
            }
        }

        // Try to parse partial JSON by closing open structures
        function tryParsePartialJSON(jsonText) {
            try {
                // Find the last complete job entry
                // Jobs look like: "jobname": { "recent": [...], "stats": {...} }
                // Find a point where we can safely truncate

                // Look for the pattern where a job's stats section ends
                const statsEndPattern = /"std_seconds":\s*[\d.]+\s*\}\s*\}/g;
                let lastMatch = null;
                let match;
                while ((match = statsEndPattern.exec(jsonText)) !== null) {
                    lastMatch = match;
                }

                if (!lastMatch) return null;

                // Truncate at the end of the last complete job and close the JSON
                const truncateAt = lastMatch.index + lastMatch[0].length;
                let partial = jsonText.slice(0, truncateAt);

                // Close any remaining open braces
                partial += '}}';  // Close jobs object and root object

                return JSON.parse(partial);
            } catch (e) {
                return null;
            }
        }

        // Render empty matrix immediately so users see structure
        function renderMatrixSkeleton() {
            const matrixContainer = document.getElementById('job-matrix');
            let html = '<table class="matrix-table">';

            // Header row
            html += '<tr><th class="matrix-corner" title="Loading...">‚ãØ</th>';
            for (const type of typeOrder) {
                html += `<th>${typeLabels[type]}</th>`;
            }
            html += '</tr>';

            // Platform rows with loading placeholders
            for (const platform of platformOrder) {
                html += `<tr><th class="row-header">${platformLabels[platform]}</th>`;
                for (const type of typeOrder) {
                    html += `<td class="matrix-cell" data-platform="${platform}" data-type="${type}">‚ãØ</td>`;
                }
                html += '</tr>';
            }

            // Special groups placeholder
            html += '<tr><th class="row-header" colspan="5" style="text-align:center; padding-top:8px;">Special</th></tr>';
            html += '<tr><td colspan="5" class="loading" style="font-size:11px;">Loading special jobs...</td></tr>';

            html += '</table>';
            matrixContainer.innerHTML = html;
        }

        async function refreshData() {
            try {
                const resp = await fetch('data/timing_summary.json');
                if (!resp.ok) return;
                const newData = await resp.json();

                // Only update if data actually changed
                if (newData.generated_at !== data.generated_at) {
                    data = newData;
                    const updatedEl = document.getElementById('last-updated');
                    updatedEl.textContent = `Updated ${timeAgo(data.generated_at)}`;
                    updatedEl.title = data.generated_at;
                    updateChart();
                    updateStatsTable();
                } else {
                    // Update the "ago" time even if data hasn't changed
                    const updatedEl = document.getElementById('last-updated');
                    updatedEl.textContent = `Updated ${timeAgo(data.generated_at)}`;
                }
            } catch (err) {
                // Silently ignore refresh errors
            }
        }

        loadData();

        // Auto-refresh data periodically
        setInterval(refreshData, DATA_REFRESH_INTERVAL);

        // Update "ago" time periodically
        setInterval(() => {
            if (data?.generated_at) {
                const updatedEl = document.getElementById('last-updated');
                updatedEl.textContent = `Updated ${timeAgo(data.generated_at)}`;
            }
        }, AGO_UPDATE_INTERVAL);

        // Re-render chart when color scheme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
            if (selectedJobs.size > 0) updateChart();
        });
    </script>
</body>
</html>